;; This is a simple proposal contract aimd to store votes as transactions
;; Future versions of the platform will support voting with offchain signatures 
;; and storage on Ton Storage and will not require this contract

(int, int, int, cell) load_data() inline {
    slice ds = get_data().begin_parse();

    int proposal_start_time = ds~load_uint(64);
    int proposal_end_time = ds~load_uint(64);
    int proposal_snapshot_time = ds~load_uint(64);
    cell frozen_addresses = ds~load_ref();
	ds.end_parse();

    return (proposal_start_time, proposal_end_time, proposal_snapshot_time, frozen_addresses);
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) {
    var (proposal_start_time, proposal_end_time, proposal_snapshot_time, frozen_addresses) = load_data();
    throw_unless(0x1000, now() > proposal_start_time);
    throw_unless(0x1001, now() < proposal_end_time);

    return ();
}

(int) proposal_start_time() method_id {
    var (proposal_start_time, proposal_end_time, proposal_snapshot_time, frozen_addresses) = load_data();
    return proposal_start_time;
}

(int) proposal_end_time() method_id {
    var (proposal_start_time, proposal_end_time, proposal_snapshot_time, frozen_addresses) = load_data();
    return proposal_end_time;
}

(int) proposal_snapshot_time() method_id {
    var (proposal_start_time, proposal_end_time, proposal_snapshot_time, frozen_addresses) = load_data();
    return proposal_snapshot_time;
}

(cell) frozen_addresses() method_id {
    var (proposal_start_time, proposal_end_time, proposal_snapshot_time, frozen_addresses) = load_data();
    return frozen_addresses;
}